# -*- coding: utf-8 -*-
"""Python Project_Olist Analyst.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K5kYTn3dpxAVT6y3AVv5ZGHqwd50mcjT

# Olist Store Case Study

The objective of Olist this year is to grow total sales revenue (please note that Olist has no control over the prices and shipping charges set by its partners)

## Analyst Framework

Objective: Increase Olist's total sales revenue by 10%
(Olist has no control over the prices and shipping charges set by its partners)

Sale Revenue = # of Unit Sold  x  Average Selling Price

Number of Unit Sold:

1. **Oppertunities 1:** Increase Olist's total sales revenue by 10%
(Olist has no control over the prices and shipping charges set by its partners)

2. **Oppertunities 2:** Increase order frequency (more orders per person per week)

3. **Oppertunities 3:** Increase order size (more items per order)

## Key Recommendations

1. **INCREASE CUSTOMERS**

*   Strengthen marketing and promotional strategies in Sao Paulo (the area with the highest demand) with products like bath tables and health beauty items to attract new customers.
*   Analyze the reasons for long preparation times in MA, RN, and MS, and warn merchants with high revenue but large order delays to reduce preparation times.
*   Prioritize allocating shipping resources to areas with long delivery times (RR, AP, AM, AL, PA) and high delivery delay rates (CR, PI, SE, MA, AL) to reduce delivery times and increase shipping efficiency.
*   Optimize credit card payment methods, the most preferred method, to ensure a smooth experience and reduce errors to under 0.5%.

2. **INCREASE ORDER FREQUENCY:**

*   Intensify sending emails/push notifications during peak hours (10 AM-4 PM and 8 PM-9 PM) and optimize the customer support team to boost orders.


3. **INCREASE NUMBER OF ITEM/ ORDERS**

*   Encourage customers to buy more items per order through bulk discounts and by suggesting suitable product bundles.

## Output
1. Analyst framework
2. Prepare Data
3. Data Analytics
4. Turning Insights into Business Recommendations
"""

from google.colab import drive
drive.mount('/content/drive')

"""1. Problem-solving framework
   
   1. Clear Problem:
      
      What was the revenue for the past 6 months?
      How much was your marketing spend last quarter?

   2. Unclear Problem:
      
      Why are customers no longer using our service?
      What is causing the drop in website traffic?
      Analyze customer experience to increase revenue next year

Problem-solving framework:
1. Understand and clarify the problem statement:
   
   Objective: Why we need to analyze this problem?

   5W1H: Why, who, what, when, how

   CPCC: Company, Product, Customer, Competition

   Problem formulation:

    1. SMART objectives (constrains priorities)

    2. Scope of the problem

    3. Since when are you facing the problem?

    4. Magnitude of the problem

    5. Why certain decisions being taken now?
    (Market Entry Cases)

    6. Geography specific?

  Company:
  
    1. Business lines and revenue segments

    2. Locations - Plants, Sales

    3. Business Model and Distribution Model

    4. Scale of operation

    5. Type of player - Low cost or differentiated

    6. How old is the company

  Product:
    
    1. SKUs - type, variants, sizes

    2. USP of the product

    3. Revenue share by product

    4. Is the problem specific to the product?

  Customer:
    
    1. How are the customers segmented

    2. Customer segments served?

    3. Different customer and consumer?

    4. Revenue contribution of channel partners

    5. Is the problem specific to a customer segment?

  Competition:

    1. Who are the competitors and what are their market shares?

    2. Who are the indirect competitiors?

    3. Fragmented and concentrated industry

    4. Are competitors also facing the issue?
2. Structure the problem (chia nho van de):
   
    Nguyen tac MECE:
        Mutually Exclusive (Khong chong cheo)
        Collectively Exhaustive (Bao quat toan bo)

    Quy luat 80/20:
        Sap xep quan trong len dau, it quan trong de sau
        Quy tac 20, sap xep 20% nguyen nhan anh huong den 80% den main point len truoc

    Nguyen tac MECE: theo cau truc dai so

    Vi du profit = revenue - cost

    Nguyen tac MECE: theo cau truc quy trinh

    Vi du buoc nhan thuc -> truy cap -> quy trinh

# 1. Load and Clean data
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

df_customers = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/customers.csv')
df_geolocation = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/geolocation.csv')
df_sellers = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/sellers.csv')

df_category_name = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/product_category_name_translation.csv')
df_products = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/products.csv')
df_payments = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/order_payments.csv')

df_orders =pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/orders.csv')
df_items = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/order_items.csv')
df_reviews = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/order_reviews.csv')

dfs = [df_category_name, df_customers, df_geolocation, df_items, df_orders, df_payments,

       df_products, df_reviews, df_sellers]

df_names = ['df_category_name', 'df_customers', 'df_geolocation', 'df_items', 'df_orders',

            'df_payments', 'df_products', 'df_reviews','df_sellers']

summary_data = []

for df, name in zip(dfs, df_names):

    shape = df.shape  # (số dòng, số cột)

    columns = list(df.columns)  # Tên các cột

    summary_data.append({

        'Tên bảng': name,

        'Shape': shape,

        'Tên cột': columns,

    })

# Tạo DataFrame từ thông tin tổng hợp

summary_df = pd.DataFrame(summary_data)

summary_df

"""## Clean data

### Merge data
"""

# Bat dau tu bang fact (bang chua cac cot do luong)
df1 = pd.merge(df_items,df_orders,on = 'order_id', how = 'left')
df2 = pd.merge(df1,df_payments, on = 'order_id', how = 'left')
df3 = pd.merge(df2,df_products, on = 'product_id', how = 'left')
df4 = pd.merge(df3,df_customers, on = 'customer_id',how = 'left')
df5 = pd.merge(df4,df_sellers, on = 'seller_id',how = 'left')
df6 = pd.merge(df5,df_category_name, on = 'product_category_name',how = 'left')
df_reviews = df_reviews.sort_values(by = 'review_creation_date', ascending = False).drop_duplicates(subset = 'order_id', keep = 'first')
df = pd.merge(df6,df_reviews, on = 'order_id', how = 'left')
df.count()

df2[df2.duplicated(subset =['order_id','order_item_id'],keep = False)]

df_reviews[df_reviews.duplicated(subset = 'order_id',keep = False)].sort_values('order_id')

df_reviews = df_reviews.sort_values(by = 'review_creation_date', ascending = False).drop_duplicates(subset = 'order_id', keep = 'first')

"""### Data Type"""

# datatype
# typo => pass
# duplicate => pass
# missing data

df.info()

cols = ['shipping_limit_date', 'order_purchase_timestamp', 'order_approved_at','order_delivered_carrier_date','order_delivered_customer_date','order_estimated_delivery_date']
def convert_datetime(col):
    df[col] = pd.to_datetime(df[col])
for col in cols:
    convert_datetime(col)

df.info()

"""### Missing data"""

def calc_nul_value(df):
    new_df = df.isna().sum().to_frame('count_null')
    new_df['% null'] = 100*new_df['count_null']/len(df)
    return new_df
calc_nul_value(df)

df['order_approved_at'] = df['order_approved_at'].fillna(df['order_purchase_timestamp'])
df['order_delivered_customer_date'] = df['order_delivered_customer_date'].fillna(df['order_estimated_delivery_date'])

df['product_category_name_english'] = df['product_category_name_english'].fillna('Unknown')
calc_nul_value(df)

"""### View"""

df.describe()

"""# Analyze

## Opportunity 1: More Customers

###  Acquiring new customers

####   Status of Acquiring New Customers
"""

# Mỗi tháng Olist có bao nhiêu khách hàng mới
first_purchase = df.groupby('customer_unique_id')['order_purchase_timestamp'].min().reset_index().rename(columns={'order_purchase_timestamp':'first_purchase_date'})
first_purchase['first_purchase_month']=first_purchase['first_purchase_date'].dt.to_period('M')
new_customer = first_purchase.groupby('first_purchase_month').agg(count_customer = ('customer_unique_id','count')).reset_index()

plt.figure(figsize=(12,6))
sns.barplot(data=new_customer, x='first_purchase_month', y='count_customer', palette='Blues')

for index, row in new_customer.iterrows():
    plt.text(x=index,
             y=row['count_customer'] + 1,  # Đặt số liệu lên trên một chút
             s=int(row['count_customer']),
             ha='center', va='bottom')

plt.xticks(rotation=45)
plt.title('Number of New Customers by Month')
plt.xlabel('Month')
plt.ylabel('Number of New Customers')

# Xóa khung biểu đồ
plt.gca().spines[['top', 'right', 'left', 'bottom']].set_visible(False)

# Đảm bảo gridline nằm phía sau biểu đồ
plt.gca().set_axisbelow(True)
plt.grid(True, linestyle='--', alpha=0.7, axis='y')  # Gridline trên trục Y với nét đứt

plt.show()

"""Từ 01/2017 - 12/2017 số lượng khách hàng mới tăng trưởng đều đặn, trong đó 11/2017 số lượng khách hàng mới tăng đột biến do black friday
Từ 01/2018 - 01/2018 số lượng khách hàng mới có giảm nhẹ nhưng vẫn duy trì ở mức ổn định từ 6000-7000 khách hàng
"""

# state, city
top_state = df.groupby('customer_state').agg(count_customer=('customer_unique_id','nunique')).reset_index().sort_values(by = 'count_customer',ascending = False).head(10)

ax = sns.barplot(data = top_state, x = 'customer_state',
            y = 'count_customer')
n =df ['customer_id'].nunique()
for p in ax.patches:
    ax.annotate(f'{100*int(p.get_height())/n: .2f}%',
              (p.get_x() + p.get_width()/ 2., p.get_height()),
              ha ='center', va = 'center',
              xytext = (0,5), textcoords = 'offset points')
plt.xticks(rotation = 45)
plt.title('Top 10 number of customers by State')
plt.xlabel('State')
plt.ylabel('Number of customer')
plt.show()

"""####   Top areas with the highest performance?"""

top_city = df.groupby('customer_city').agg(count_customer=('customer_unique_id','nunique')) \
             .reset_index().sort_values(by='count_customer', ascending=False).head(5)

plt.figure(figsize = (12,4))
ax = sns.barplot(data=top_city, y='customer_city', x='count_customer', palette='Blues')

n = df['customer_unique_id'].nunique()
for p in ax.patches:
    ax.text(p.get_width() / 2, p.get_y() + p.get_height() / 2,
            f'{100 * int(p.get_width()) / n:.2f}%',
            ha='center', va='center')

# Xóa khung biểu đồ
ax.spines[['top', 'right', 'left', 'bottom']].set_visible(False)

# Thêm gridline theo chiều dọc
ax.set_axisbelow(True)  # Đưa gridline xuống dưới
plt.grid(True, linestyle='--', alpha=0.7, axis='x')  # Gridline dọc (trục X)

plt.title('Top 5 Number of Customers by City')
plt.xlabel('Number of Customers')
plt.ylabel('')

plt.show()

"""sao paulo là thành phố có số lượng khách hàng tập trung nhiều nhất 15.61%"""

# Số lượng đơn hàng cuẩ từng sản phẩm
df.groupby('product_category_name_english').agg(count_order = ('order_id','nunique')).reset_index().sort_values(by = 'count_order',ascending = False)

plt.figure(figsize=(10,4))

top_product = df[df['customer_city'] == 'sao paulo'] \
    .groupby('product_category_name_english') \
    .agg(count_order=('order_id', 'nunique')) \
    .reset_index() \
    .sort_values(by='count_order', ascending=False) \
    .head(5)

ax = sns.barplot(data=top_product,
                 y='product_category_name_english',
                 x='count_order',
                 palette='Blues')

# Thêm số liệu vào thanh biểu đồ
n = df['customer_unique_id'].nunique()
for p in ax.patches:
    ax.text(p.get_width() / 2, p.get_y() + p.get_height() / 2,
            f'{100 * int(p.get_width()) / n:.2f}%',
            ha='center', va='center')

# Xóa khung biểu đồ
ax.spines[['top', 'right', 'left', 'bottom']].set_visible(False)

# Thêm gridline dọc (trục X)
ax.set_axisbelow(True)  # Đảm bảo gridline nằm phía sau cột
plt.grid(True, linestyle='--', alpha=0.7, axis='x')

plt.title('Top 5 Ordered Product Categories in Sao Paulo')
plt.xlabel('Number of Orders')
plt.ylabel('Product Category')

plt.show()

cities = ['sao paulo', 'rio de janeiro', 'belo horizonte', 'brasilia']

plt.figure(figsize=(12, 6))

for i, city in enumerate(cities, 1):
    plt.subplot(2, 2, i)

    # Lọc dữ liệu và tính số lượng đơn hàng theo danh mục sản phẩm
    top_product = df[df['customer_city'] == city] \
        .groupby('product_category_name_english') \
        .agg(count_order=('order_id', 'nunique')) \
        .reset_index() \
        .sort_values(by='count_order', ascending=False) \
        .head(5)

    total_orders = top_product['count_order'].sum()  # Tổng số đơn hàng trong top 5

    ax = sns.barplot(data=top_product,
                     y='product_category_name_english',
                     x='count_order',
                     palette='Blues')

    # Thêm số liệu phần trăm vào trong biểu đồ
    for p in ax.patches:
        percentage = 100 * p.get_width() / total_orders  # Tính phần trăm
        ax.text(p.get_width() - 1,  # Dịch số về bên trái một chút
                p.get_y() + p.get_height() / 2,
                f'{percentage:.1f}%',  # Hiển thị với 1 chữ số thập phân
                ha='right', va='center', color='black', fontsize=10)

    plt.xlabel('Number of Orders')
    plt.ylabel('Product')
    plt.title(f'Number of Orders in {city}')

plt.tight_layout()
plt.show()

"""#### Top merchants with the highest performance?"""

# Số lượng đơn hàng
# Doanh thu
# Đánh giá của khách hàng
df_bed_bad_table = df[df['product_category_name_english'] == 'bed_bath_table']\
[['order_id','seller_id','payment_value','review_score']]
top_merchant = df_bed_bad_table.groupby('seller_id').agg(count_order=('order_id','nunique'),
                            revenue = ('payment_value','sum'),
                            score = ('review_score','mean')).reset_index()
top_merchant[(top_merchant['count_order']>top_merchant['count_order'].mean())
& (top_merchant['revenue']>top_merchant['revenue'].mean())].sort_values(by = 'score',ascending = False)\
  .head(5).style.background_gradient()

df_health_beauty = df[df['product_category_name_english'] == 'health_beauty']\
[['order_id','seller_id','payment_value','review_score']]
top_merchant = df_health_beauty.groupby('seller_id').agg(count_order=('order_id','nunique'),
                            revenue = ('payment_value','sum'),
                            score = ('review_score','mean')).reset_index()
top_merchant[(top_merchant['count_order']>top_merchant['count_order'].mean())
& (top_merchant['revenue']>top_merchant['revenue'].mean())].sort_values(by = 'score',ascending = False)\
  .head(5).style.background_gradient()

"""### Retain Existing Customers

#### Status of customer repeat purchases
"""

from operator import attrgetter

df_selected_date = df[(df['order_purchase_timestamp']>='2018-01-01') &
                      (df['order_purchase_timestamp'] < '2019-01-01')]
df_first_purchase = df_selected_date.groupby('customer_unique_id')\
                    .agg(first_purchase_date = ('order_purchase_timestamp','min')).reset_index()
df_first_purchase['first_purchase_date'] = df_first_purchase['first_purchase_date'].dt.to_period('M')
df_selected_date = pd.merge(df_selected_date,df_first_purchase, on ='customer_unique_id', how = 'left')
df_selected_date
df_selected_date['current_month']= df_selected_date['order_purchase_timestamp'].dt.to_period('M')
df_selected_date['delta_month'] = (df_selected_date['current_month'] - df_selected_date['first_purchase_date']).apply(attrgetter('n'))
df_selected_date[df_selected_date['delta_month']>0]

df_cohort = df_selected_date.groupby(['first_purchase_date','delta_month']).agg(count_customer = ('customer_unique_id','nunique')).reset_index()

df_cohort_pivot = (
    df_cohort\
    .pivot_table(index = 'first_purchase_date',
                 columns = 'delta_month',
                 values = 'count_customer')
)
df_cohort_pivot

for col in df_cohort_pivot.columns[1:]:
    df_cohort_pivot[col] = df_cohort_pivot[col]/df_cohort_pivot[0]
df_cohort_pivot[0] = 1
df_cohort_pivot

plt.figure(figsize = (12,6))
sns.heatmap(data = df_cohort_pivot, annot = True, fmt = '.1%', cmap='Blues', linewidths=0.5,
                 cbar=True)
plt.ylabel('First purchase date')
plt.xlabel('Month')
plt.yticks(rotation = 0)
plt.show()

"""#### Delivery time
order_purchase_timestamp: Timestamp of the purchase

order_approved_at: Timestamp of the order approval

order_delivered_carrier_date: Delivery date at which carrier made the delivery

order_delivered_customer_date: Date at which customer got the product

order_estimated_delivery_date: estimated delivery date of the products

shipping_limit_date: The date before which shipping of the ordered product must be completed

"""

# thời gian hàng có tác động đến sự hài lòng của KH không?
# Tỉ lệ ontime và late như thế nào?
# thời gian giao hàng có cải thiện qua từng năm hay không?

df['dispatch_time'] = (df['order_delivered_carrier_date'] - df['order_approved_at']).dt.days
df['delivery_time'] = (df['order_delivered_customer_date'] - df['order_delivered_carrier_date']).dt.days
df['actual_vs_estimated_dispatched_time'] = (df['order_delivered_carrier_date'] - df['shipping_limit_date']).dt.days
df['actual_vs_estimated_delivery_time'] = (df['order_delivered_customer_date'] - df['order_estimated_delivery_date']).dt.days

df.head(5)

def ontime_or_late(x):
   if x>0:
      return 'late'
   else:
      return 'ontime'
df['actual_vs_estimated_dispatched_time'] = df['actual_vs_estimated_dispatched_time'].apply(ontime_or_late)
df['actual_vs_estimated_delivery_time'] = df['actual_vs_estimated_delivery_time'].apply(ontime_or_late)

df.head(2)

df['total_time'] = df['dispatch_time']+df['delivery_time']

sns.boxplot(data = df[df['total_time'] < df['total_time'].quantile(0.95)],
            x = 'review_score',
            y = 'total_time',
            palette = 'pastel')

# loại bỏ outlier
# IQR
# quantitle(0.05) <x < quantitle (0.95)

df[df['total_time'] < df['total_time'].quantile(0.95)]

# actual_vs_estimated_dispatched_time vs actual_vs_estimated_delivery_time
actual_vs_estimated_dispatched_time = df.groupby('actual_vs_estimated_dispatched_time').agg(count = ('order_id','nunique')).reset_index()

ax = sns.barplot(data = actual_vs_estimated_dispatched_time,
            x = 'actual_vs_estimated_dispatched_time',
            y = 'count',
            palette = 'pastel')
n =df['order_id'].nunique()
for p in ax.patches:
    ax.annotate(f'{100*int(p.get_height())/n: .2f}%',
              (p.get_x() + p.get_width()/ 2., p.get_height()),
              ha ='center', va = 'center',
              xytext = (0,5), textcoords = 'offset points')
#plt.xticks(rotation = 45)
plt.title('Actual vs Estimated Dispatch Time')
plt.xlabel('Status')
plt.ylabel('Number of order')
plt.show()

actual_vs_estimated_delivery_time = df.groupby('actual_vs_estimated_delivery_time').agg(count = ('order_id','nunique')).reset_index()

ax = sns.barplot(data = actual_vs_estimated_delivery_time,
            x = 'actual_vs_estimated_delivery_time',
            y = 'count',
            palette = 'pastel')
n =df['order_id'].nunique()
for p in ax.patches:
    ax.annotate(f'{100*int(p.get_height())/n: .2f}%',
              (p.get_x() + p.get_width()/ 2., p.get_height()),
              ha ='center', va = 'center',
              xytext = (0,5), textcoords = 'offset points')
#plt.xticks(rotation = 45)
plt.title('Actual vs Estimated Delivery Time')
plt.xlabel('Status')
plt.ylabel('Number of order')
plt.show()

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Biểu đồ Actual vs Estimated Dispatch Time
ax1 = sns.barplot(data=actual_vs_estimated_dispatched_time,
                  x='actual_vs_estimated_dispatched_time',
                  y='count',
                  palette='Blues', ax=axes[0])

n = df['order_id'].nunique()
for p in ax1.patches:
    ax1.annotate(f'{100 * int(p.get_height()) / n: .2f}%',
                 (p.get_x() + p.get_width() / 2., p.get_height()),
                 ha='center', va='center',
                 xytext=(0, 5), textcoords='offset points')

ax1.set_title('Actual vs Estimated Dispatch Time')
ax1.set_xlabel('Dispatch')
ax1.set_ylabel('Number of Orders')

# Biểu đồ Actual vs Estimated Delivery Time
ax2 = sns.barplot(data=actual_vs_estimated_delivery_time,
                  x='actual_vs_estimated_delivery_time',
                  y='count',
                  palette='Blues', ax=axes[1])

for p in ax2.patches:
    ax2.annotate(f'{100 * int(p.get_height()) / n: .2f}%',
                 (p.get_x() + p.get_width() / 2., p.get_height()),
                 ha='center', va='center',
                 xytext=(0, 5), textcoords='offset points')

ax2.set_title('Actual vs Estimated Delivery Time')
ax2.set_xlabel('Delivery')
ax2.set_ylabel('Number of Orders')

# Hiển thị
plt.tight_layout()
plt.show()

df['year'] = df['order_purchase_timestamp'].dt.year

# thời gian giao hàng qua mỗi năm ra sao
df.groupby('year').agg(mean = ('total_time','mean')).reset_index()

ax = sns.barplot(data = df.groupby('year').agg(mean = ('total_time','mean')).reset_index(),
            x = 'year',
            y = 'mean',
            palette = 'pastel')
for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}',
              (p.get_x() + p.get_width()/ 2., p.get_height()),
              ha ='center', va = 'center',
              xytext = (0,5), textcoords = 'offset points')
#plt.xticks(rotation = 45)
plt.title('Lead time by Year')
plt.xlabel('Year')
plt.ylabel('Average of lead time')
plt.show()

sns.kdeplot(data = df,
            x ='total_time',
            hue = 'year',
            palette = 'Blues')
plt.xlim(-10,100)

df[df['total_time']<0][['order_approved_at','order_delivered_carrier_date']]

"""##### Dispatch Time( Seller)

"""

# Thời gian chuẩn bị 1 đơn hàng trung bình
avg_dispatch_time = df.groupby('seller_state').agg(avg_dispatch_time=('dispatch_time', 'mean')).reset_index() \
    .sort_values(by='avg_dispatch_time', ascending=False)

# Vẽ biểu đồ
plt.figure(figsize=(12, 6))
ax = sns.barplot(data=avg_dispatch_time,
                 x='seller_state',
                 y='avg_dispatch_time',
                 palette = 'Blues')

# Thêm số liệu vào trong các cột
for p in ax.patches:
    ax.annotate(f'{(p.get_height()): .2f}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                xytext=(0, 5), textcoords='offset points')

# Xóa khung biểu đồ
ax.spines[['top', 'right', 'left', 'bottom']].set_visible(False)

# Thêm đường average line (giữa các giá trị dispatch time)
average_value = avg_dispatch_time['avg_dispatch_time'].mean()
ax.axhline(average_value, color='red', linestyle='--', label=f'Mean: {average_value:.2f}')

# Thêm chú thích cho đường trung bình
ax.legend()

# Cài đặt tiêu đề và nhãn trục
plt.title('Average Dispatch Time by Seller State')
plt.xlabel('Seller State')
plt.ylabel('Average Dispatch Time')

# Hiển thị biểu đồ
plt.show()

df[df['seller_state'].isin(['MA','RN','MS'])]
sns.boxplot(data = df[df['seller_state'].isin(['MA','RN','MS'])],
            x = 'seller_state',
            y = 'dispatch_time')

df[(df['seller_state'] == 'MA') & (df['dispatch_time']>15)][['product_category_name_english','seller_id']].value_counts()

df[(df['seller_state'] == 'RN') & (df['dispatch_time']>10)][['product_category_name_english','seller_id']].value_counts()

# Seller nào đang trong tình trạng cảnh báo về thời gian chuẩn bị đơn hàng

sellers = df[['order_id','seller_id','payment_value']].drop_duplicates().groupby('seller_id').agg(count_order = ('order_id','nunique'),
                             revenue = ('payment_value','sum'))
sellers_late_time =df[df['actual_vs_estimated_dispatched_time'] == 'late'].groupby('seller_id').agg(late_count = ('order_id','nunique'))
sellers = pd.merge(sellers, sellers_late_time, on ='seller_id', how = 'left').fillna(0)
sellers['late_rate'] = 100*sellers['late_count']/sellers['count_order']

sellers_late = sellers[(sellers['count_order'] >=sellers['count_order'].mean()) &\
(sellers['revenue'] >=sellers['revenue'].mean())].reset_index().sort_values(by ='late_rate', ascending = False).head(10)
sellers_late[['seller_id','count_order','revenue','late_rate']].style.background_gradient()

"""##### Deliver Time( Customer)"""

# Thời gian giao hàng trung bình tại mỗi khu vực
avg_delivery_time =df.groupby('customer_state').agg(avg_delivery_time = ('delivery_time','mean')).reset_index()\
                   .sort_values(by = 'avg_delivery_time',ascending = False)
avg_delivery_time

# Vẽ biểu đồ
plt.figure(figsize=(12, 6))
ax = sns.barplot(data=avg_delivery_time,
                 x='customer_state',
                 y='avg_delivery_time',
                 palette = 'Blues')

# Thêm số liệu vào trong các cột
for p in ax.patches:
    ax.annotate(f'{(p.get_height()): .1f}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                xytext=(0, 5), textcoords='offset points')

# Xóa khung biểu đồ
ax.spines[['top', 'right', 'left', 'bottom']].set_visible(False)

# Thêm đường average line (giữa các giá trị avg_delivery_time)
average_value = avg_delivery_time['avg_delivery_time'].mean()
ax.axhline(average_value, color='red', linestyle='--', label=f'Mean: {average_value:.2f}')

# Thêm chú thích cho đường trung bình
ax.legend()

# Cài đặt tiêu đề và nhãn trục
plt.title('Average Delivery Time by Customer State')
plt.xlabel('Customer State')
plt.ylabel('Average Delivery Time')

# Hiển thị biểu đồ
plt.show()

# Tỉ lệ late và ontime theo từng khu vực
ontime_late_customer_state = (df.groupby('customer_state')['actual_vs_estimated_delivery_time'].value_counts(normalize = True)*100).reset_index()
ontime_late_customer_state['proportion'] = ontime_late_customer_state['proportion'].round(2)
ontime_late_customer_state = ontime_late_customer_state.sort_values( by = 'proportion')

ontime_late_customer_state.head(2)

plt.figure(figsize=(15, 6))
ax = sns.barplot(data=ontime_late_customer_state,
                 x='customer_state',
                 y='proportion',
                 hue='actual_vs_estimated_delivery_time',
                 palette='Blues')

# Thêm số liệu vào trong các cột
for p in ax.patches:
    ax.annotate(f'{(p.get_height()): .1f}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                xytext=(0, 5), textcoords='offset points')

# Xoá khung biểu đồ
ax.spines[['top', 'right', 'left', 'bottom']].set_visible(False)

# Cài đặt các yếu tố khác của biểu đồ
plt.xticks(rotation=65)
plt.legend(title='Time Type')
plt.title('Group Bar Chart of Proportion by State and Time Type')
plt.xlabel('Customer State')
plt.ylabel('Proportion')

# Hiển thị biểu đồ
plt.tight_layout()
plt.show()

"""#### Which payment method has the lowest success rate?"""

payment_method = df[['order_id','payment_type','payment_value']].drop_duplicates().groupby('payment_type').agg(count_order = ('order_id', 'nunique'),revenue = ('payment_value','sum')).reset_index()

ax = sns.barplot(data = payment_method, x = 'payment_type',
            y = 'count_order',
            palette = 'Blues')
n =df['order_id'].nunique()
for p in ax.patches:
    ax.annotate(f'{100*int(p.get_height())/n: .2f}%',
              (p.get_x() + p.get_width()/ 2., p.get_height()),
              ha ='center', va = 'center',
              xytext = (0,5), textcoords = 'offset points')
#plt.xticks(rotation = 45)
plt.title('Number of orders by Payment Type')
plt.xlabel('Payment Type')
plt.ylabel('Number of orders')
plt.show()

# Tỉ lệ thanh thoán success và unsuccess
df['order_status'].value_counts()

def payment_status(x):
    if x in ['unavailable','canceled']:
      return 'unsuccess'
    else:
      return 'success'
df['payment_status'] = df['order_status'].apply(payment_status)
df.head(2)

payment_failure = df[df['payment_status'] == 'unsuccess'].groupby('payment_type').agg(count_failure =('order_id','nunique')).reset_index()

payment_rate = pd.merge(payment_method, payment_failure, on = 'payment_type', how = 'left')

payment_rate['failure_rate']=100*payment_rate['count_failure']/ payment_rate['count_order']
payment_rate = payment_rate[['payment_type', 'count_order', 'revenue', 'failure_rate']]
payment_rate.style.background_gradient()

"""## Opportunity 2: Increase order frequency

### Orders Quantity Distribution
"""

# Số lượng orders theo ngày
df['date'] = df['order_purchase_timestamp'].dt.date

df.groupby('date').agg(count_order = ('order_id','nunique')).reset_index()

sns.histplot(data = df.groupby('date').agg(count_order = ('order_id','nunique')).reset_index(),
             x = 'count_order')
plt.title('Distribution of Order Quantities by Day')
plt.ylabel('Frequency')
plt.xlabel('Number of Orders')

"""Số lương đơn hàng từng ngày có range từ 0-1200 đơn, tuy nhiên tập trung chủ yếu 50-200 đơn

### Time frame with a high order volume trend
"""

# ngày nào trong tuần? giờ nào trong nào?
df['day_of_week'] = df['order_purchase_timestamp'].dt.day_of_week
df['day_name'] = df['order_purchase_timestamp'].dt.strftime('%a')
df['hour'] = df['order_purchase_timestamp'].dt.hour

order_frequency = df.groupby(['day_name','hour','day_of_week']).agg(count_order = ('order_id','nunique')).reset_index()

order_frequency = order_frequency.set_index('day_name')

order_frequency_pivot = (
    order_frequency\
    .pivot_table(index = ['day_name', 'day_of_week'],
                 columns = 'hour',
                 values = 'count_order')
)
order_frequency_pivot = order_frequency_pivot.sort_values(by='day_of_week').reset_index().drop(columns = 'day_of_week')
order_frequency_pivot = order_frequency_pivot.set_index('day_name')

plt.figure(figsize = (15,6))
sns.heatmap(data = order_frequency_pivot,
            annot = True,
            fmt = '.0f',
            cmap='Blues')
plt.ylabel('')
plt.xlabel('hour')
plt.yticks(rotation = 0)
plt.show()

"""Hầu hết các đơn hàng được đặt trong các ngày trong tuần từ 10h sáng đến 4h chiều, với 1 sự giảm nhẹ doanh số vào khoảng 12h trưa do nghỉ trưa

Khách hàng cũng thường đặt qua Olist buổi tối khoảng 9h tối từ chủ nhật tới thứ năm

Thời gian ít hoạt động nhất là từ 2h sáng đến 6h sáng

### RFM customer segmentation

Recency: How recently did the customer place the last order?

Frequency: How often does the customer place orders?

Monetary value: How much does the customer spend on average?
"""

recency_cust = df.groupby('customer_unique_id').agg(max_order_purchase_timestamp = ('order_purchase_timestamp','max')).reset_index()
recency_cust['recency'] = (pd.to_datetime('2018-09-01')-recency_cust['max_order_purchase_timestamp']).dt.days
recency_cust

frequency_cust = df.groupby('customer_unique_id').agg(frequency = ('order_id','nunique')).reset_index()
frequency_cust

monetary_cust = df[['order_id','customer_unique_id','payment_value']].drop_duplicates().groupby('customer_unique_id').agg(monetary = ('payment_value','sum')).reset_index()
monetary_cust

rf = pd.merge(recency_cust, frequency_cust, on = 'customer_unique_id', how = 'inner')
rfm = pd.merge(rf, monetary_cust, on = 'customer_unique_id', how = 'inner')
rfm

sns.histplot(data = rfm,
            x = 'recency',
            kde = True,
            stat = 'density')
plt.title('Recency distribution')
plt.xlabel(None)

plt.subplot(3,1,2)
sns.histplot(data = rfm,
             x = 'frequency',
             kde = True,
             stat = 'density')
plt.title('Frequency distribution')
plt.xlabel(None)

sns.histplot(data = rfm,
            x = 'monetary',
            kde = True,
            stat = 'density')
plt.title('Monetary distribution')
plt.xlabel(None)

rfm[rfm['monetary']>100000]

df[df['customer_unique_id'] == '0a0a92112bd4c708ca5fde585afaa872']['payment_value']

r_quantiles = np.percentile(rfm['recency'],[20,40,60,80])
f_quantiles = np.percentile(rfm['frequency'],[20,40,60,80])
m_quantiles = np.percentile(rfm['monetary'],[20,40,60,80])
r_quantiles

def RScore(x,quantiles):
    if x <=quantiles[0]: # Dùng phân vị 20% (index 0 )
       return 5
    elif x <=quantiles[1]: # Dùng phân vị 40% (index 1 )
       return 4
    elif x <=quantiles[2]: # Dùng phân vị 60% (index 2 )
       return 3
    elif x <=quantiles[3]: # Dùng phân vị 80% (index 3 )
       return 2
    else:
       return 1

def FMScore(x,quantiles):
    if x <=quantiles[0]: # Dùng phân vị 20% (index 0 )
       return 1
    elif x <=quantiles[1]: # Dùng phân vị 40% (index 1 )
       return 2
    elif x <=quantiles[2]: # Dùng phân vị 60% (index 2 )
       return 3
    elif x <=quantiles[3]: # Dùng phân vị 80% (index 3 )
       return 4
    else:
       return 5

rfm['r'] = rfm['recency'].apply(RScore, quantiles = r_quantiles)
rfm['f'] = rfm['frequency'].apply(FMScore, quantiles = f_quantiles)
rfm['m'] = rfm['monetary'].apply(FMScore, quantiles = m_quantiles)
rfm.head(5)

rfm['score'] = (rfm['r'].astype(str) + rfm['f'].astype(str) + rfm['m'].astype(str)).astype(int)
rfm.head(5)

rfm.head(5)

segment_score = pd.read_csv('/content/drive/MyDrive/Julie/ecomerce_dataset/segment_score1.csv')
segment_score

cst_sgmt = pd.merge(rfm,segment_score,left_on = 'score',right_on = 'SCORES', how = 'inner')
cst_sgmt.head(5)

data = cst_sgmt.groupby('SEGMENT').agg(cnt = ('customer_unique_id','nunique')).reset_index()\
.sort_values(by = 'cnt', ascending = False)
data.head(2)

ax = sns.barplot(x = 'cnt',y = 'SEGMENT', data = data, palette = 'pastel')
n = cst_sgmt['customer_unique_id'].nunique()
for p in ax.patches:
    ax.text(p.get_width()+2000, p.get_y() + p.get_height()/2,
            f'{100*int(p.get_width())/n: .2f}%',
            ha = 'center', va = 'center')

"""## Opportunity 3: Increase the # of Items/ Order

####  Average order size
"""

# Khách hàng mua bao nhiêu item trên 1 order
count_item = df.groupby('order_id').agg(count_item = ('order_item_id', 'nunique')).reset_index()

plt.figure(figsize=(12, 6))
ax = sns.countplot(data=count_item, x='count_item')

# Tính tổng số lượng để tính phần trăm
total_count = count_item['count_item'].count()

# Thêm số liệu phần trăm vào trong biểu đồ
for p in ax.patches:
    height = p.get_height()
    percentage = (height / total_count) * 100
    ax.annotate(f'{percentage:.2f}%',
                (p.get_x() + p.get_width() / 2., height),
                ha='center', va='center',
                xytext=(0, 5), textcoords='offset points')

# Xoá khung biểu đồ
ax.spines[['top', 'right', 'left', 'bottom']].set_visible(False)

# Cài đặt các yếu tố khác của biểu đồ
plt.title('Distribution of Item Counts')
plt.xlabel('Item Count')
plt.ylabel('Frequency')

# Hiển thị biểu đồ
plt.tight_layout()
plt.show()

# bao nhiêu % khách hàng mua 2 sản phẩm trở lên
count_item['count_item'].quantile(0.91)
# 91% khách hàng mua dưới 2 item/1 order

"""#### Which products are commonly bought together?"""

# order nào mà có 2 sản phẩm khác nhau
df.groupby('order_id').agg(count_pd = ('product_id', 'nunique')).reset_index().sort_values(by = 'count_pd',ascending = False)

df[df['order_id']=='56ce64b53ec3bb5b0525f21506619f8e']

pd_tuple = pd.merge(df,df,on ='order_id', how = 'inner')
pd_tuple = pd_tuple[pd_tuple['product_id_x']<pd_tuple['product_id_y']]

pd_tuple.head(2)

# có bn order_id mà chứa cặp pr_x, pr_y
pd_freq_tuple = pd_tuple.groupby(['product_id_x','product_id_y']).agg(count_order = ('order_id','nunique')).reset_index()\
.sort_values(by = 'count_order',ascending = False)

pd_freq_tuple[pd_freq_tuple['count_order']>10]

