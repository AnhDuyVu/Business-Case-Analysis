# -*- coding: utf-8 -*-
"""Vu_Anh_Duy_RFM_analysis_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rD8ZqqpLXFK3OvdLSl0C8UY3w9hw3NY4

**Problem Statement:**

The SuperStore company is a global retail company with a large customer base. In light of the Christmas and New Year holidays, the Marketing department wants to run marketing campaigns to express gratitude to customers who have supported the company over time. They also want to identify and engage potential customers to turn them into loyal customers.

However, the Marketing department hasn't yet segmented the customers for this year because the dataset is too large to handle manually, unlike in previous years. They are seeking support from the Data Analysis department to implement a customer segmentation task for each customer segment, allowing them to deploy tailored marketing programs for each customer group.

The Marketing Director has also proposed using an RFM (Recency, Frequency, Monetary) model. However, in the past, when the company was smaller in scale, the team could calculate and categorize customers using Excel. Given the current large volume of data, they are hoping that the Data department can create a segmentation strategy using Python programming to assess customer segments and aid in campaign deployment.

**Steps for RFM analysis:**

**1. Import necessary library**

**2. Exploratory Data Analysis:**
    
   1. **Overvỉew the data:**Taking an overview of the data types, the number of columns, and the number of data rows to see if there is a need to change data types to align with the analysis, is it necessary?

   2. **Detect and solve missing values:** Check if there are any missing values in the data, and determine whether these missing values impact the analysis results or not.
   3. **Detect and solve outlier values:** Check if there are any outlier values in the data and assess whether these outlier values impact the analysis results or not.

**3. Preparing data for RFM Analysis**

**4. Calculate RFM metric**

**Recency:** For each customer group, when was the most recent purchase made?

**Frequency:**
What is the frequency of purchases for each customer group?

**Monetary:** How much revenue does each customer group generate?

**5. Customer segmentation base on RFM score**


Grouping customers based on RFM scores:

1. ***Champions:***The customers who have made the most recent purchases, most frequent purchases, and spent the most.

2.   ***Loyal customers:*** Frequent buyers who are often interested in promotional campaigns.

3. ***Potential loyalist:***
Customers who have recent activity with average frequency.

4. ***New/Recent customers:*** Most recent buyers but not frequent shoppers.

5. ***Promising:***
Those who have shopped recently but haven't spent much.

6. ***Needs attention:*** The value of the most recent purchase, frequency, and monetary value are around average. It's possible that they haven't made a purchase very recently.

7. ***About to sleep:*** Frequency and recent frequency are below average. These customers might churn if there are no actions to re-engage them.

8. ***At risk:*** Customers who haven't made a purchase in a long time and need to be encouraged to start shopping again.

9. ***Can’t lose them:***
Frequent buyers who haven't returned for a while.
10. ***Hibernating:*** Last purchase was a long time ago, and the number of orders is low. They may be at risk of churn.

11. ***Lost***: Customers who have already churned/left us.

**6. RFM Analysis and Customer segmentation visualization**

**7. Suggest recommendation for marketing team to target customers in campaign**

# 1. Import necessary library
"""

from google.colab import drive
drive.mount('/content/gdrive', force_remount = True)

import numpy as np
import pandas as pd
import datetime as dt
import matplotlib.pyplot as plt
import seaborn as sns

"""#2. Exploratory Data Analysis

## Exploratory
"""

order_table = pd.read_excel("/content/gdrive/MyDrive/K15_Vu_Anh_Duy_RFM_analysis_project/Dataset.xlsx", sheet_name='Orders')

return_table = pd.read_excel("/content/gdrive/MyDrive/K15_Vu_Anh_Duy_RFM_analysis_project/Dataset.xlsx", sheet_name='Return')

print(order_table.shape)
order_table.head(10)

order_table.info()

order_table.describe()

print(return_table.shape)
return_table.head(10)

return_table.info()

return_table.describe()

"""## Clean data

### Check missing data
"""

order_table.isnull().sum()

return_table.isnull().sum()

"""###Check outlier value"""

fig, axes = plt.subplots(1, 2, figsize = (15, 5))
sns.kdeplot(order_table["Unit Cost"], ax = axes[0]).set_title("Distribution of Unit Cost")
sns.boxplot(y = order_table["Unit Cost"], ax = axes[1], color = "#195190").set_title("Boxplot for Unit Cost")
plt.show()

# determine minimum and maximum of data for assign outlier
q_minimum = order_table['Unit Cost'].quantile(0.0015)
q_maximum = order_table['Unit Cost'].quantile(0.9985)
print("With Unit Cost, the range of not outlier values are between " + str(q_minimum) + " and " + str(q_maximum) + ". Any value outside of these ranges should be considered outliers.")

# assign outlier as q_minimum and q_maximum
order_table['Unit Cost_no outlier'] = np.where(order_table['Unit Cost'] > q_maximum,q_maximum, order_table['Unit Cost'])
order_table['Unit Cost_no outlier'] = np.where(order_table['Unit Cost'] < q_minimum,q_minimum, order_table['Unit Cost'])
print(order_table.shape)
order_table.head(30)

fig, axes = plt.subplots(1, 2, figsize = (15, 5))
sns.kdeplot(order_table["Quantity"], ax = axes[0]).set_title("Distribution of Quantity")
sns.boxplot(y = order_table["Unit Cost"], ax = axes[1], color = "#195190").set_title("Boxplot for Quantity")
plt.show()

# determine minimum and maximum of data for assign outlier
q_minimum = order_table['Quantity'].quantile(0.0015)
q_maximum = order_table['Quantity'].quantile(0.9985)
print("With Unit Cost, the range of not outlier values are between " + str(q_minimum) + " and " + str(q_maximum) + ". Any value outside of these ranges should be considered outliers.")

# assign outlier as q_minimum and q_maximum
order_table['Quantity_no outlier'] = np.where(order_table['Quantity'] > q_maximum,q_maximum, order_table['Quantity'])
order_table['Quantity_no outlier'] = np.where(order_table['Quantity'] < q_minimum,q_minimum, order_table['Quantity'])
print(order_table.shape)
order_table.head(30)

"""#3. Preparing Data for RFM Analysis"""

final_table_RFM = order_table.merge(return_table, on = 'Order ID',how = 'left')
final_table_RFM

# Take order ID without return
final_table_RFM_no_return= final_table_RFM[final_table_RFM['Returned'].isnull()]
final_table_RFM_no_return

final_table_RFM_no_return['TotalRevenue'] = final_table_RFM_no_return['Unit Cost_no outlier'] * final_table_RFM_no_return['Quantity_no outlier']
Current_date = dt.datetime(2017,12,31)
final_table_RFM_no_return

segmentation_table = pd.read_excel("/content/gdrive/MyDrive/K15_Vu_Anh_Duy_RFM_analysis_project/Dataset.xlsx", sheet_name='Segmentation')
segmentation_table

segmentation_table['RFM Score'] = segmentation_table['RFM Score'].str.split(',')
segmentation_table = segmentation_table.explode('RFM Score').reset_index(drop =True)
segmentation_table['RFM Score'] = segmentation_table['RFM Score'].astype(int)
segmentation_table.sort_values(by = 'RFM Score')
segmentation_table_edit = segmentation_table
segmentation_table_edit

"""#4. Calculate RFM metric"""

rfm_data = final_table_RFM_no_return.groupby(['Customer ID']).agg({'Order Date': lambda x: (Current_date - x.max()).days ,
                                           'Order ID': lambda x: x.nunique(),
                                           'TotalRevenue': lambda x: x.sum()})

# Rename columns
rfm_data.rename(columns = {'Order Date' : 'Recency',
                      'Order ID' : 'Frequency',
                      'TotalRevenue' : 'Monetary'}, inplace = True)
# Sample RFM data
rfm_data.head()

#Building RFM segments
r_labels =range(5,0,-1)
f_labels=range(1,6)
m_labels=range(1,6)
r_quartiles = pd.qcut(rfm_data['Recency'], q=5, labels = r_labels)
f_quartiles = pd.qcut(rfm_data['Frequency'].rank(method = "first"),q=5, labels = f_labels)
m_quartiles = pd.qcut(rfm_data['Monetary'],q=5,labels = m_labels)
rfm_data = rfm_data.assign(R=r_quartiles,F=f_quartiles,M=m_quartiles)

rfm_data['RFM_Score'] = rfm_data['R'].astype(str) + rfm_data['F'].astype(str) + rfm_data['M'].astype(str)
rfm_data['RFM_Score'] = rfm_data['RFM_Score'].astype(int)
rfm_data.head()

"""#5. Customer Segmentation base on RFM score"""

segmentation_table_edit

RFM_score_table = rfm_data.merge(segmentation_table_edit, left_on = 'RFM_Score', right_on = 'RFM Score', how = 'inner')
RFM_score_table

# check null data from Segment
RFM_score_table["Segment"].isnull().sum()

"""#6.  RFM Analysis and Customer segmentation visualization"""

RFM_score_table[['Recency','Frequency','Monetary','Segment']].groupby('Segment').agg({'count','mean','std','max','min'})

RFM_score_table[['Recency','Monetary','Frequency']].agg({'count', 'mean','std','max','min','sum'})

plt.figure(figsize = (18, 8))
ax = sns.countplot(data = RFM_score_table,
                   x = 'Segment',
                   order = RFM_score_table['Segment'].value_counts().index,
                   palette = 'Set2')
total = len(RFM_score_table.Segment)
for patch in ax.patches:
    percentage = '{:.1f}%'.format(100 * patch.get_height()/total)
    x = patch.get_x() + patch.get_width() / 2 - 0.17
    y = patch.get_y() + patch.get_height() * 1.005
    ax.annotate(percentage, (x, y), size = 14)
plt.title('Number of Customers by Segments', size = 16)
plt.xlabel('Segment', size = 14)
plt.ylabel('Count', size = 14)
plt.xticks(size = 10)
plt.yticks(size = 10)
plt.show()

sns.boxplot(data = RFM_score_table, x = 'Recency', y = 'Segment', palette= "Set2")
plt.title("Recency by Customer Segmentation")
plt.tight_layout()
plt.show()

sns.boxplot(data = RFM_score_table, x = 'Monetary', y = 'Segment', palette= "Set2")
plt.title("Monetary by Customer Segment")
plt.tight_layout()
plt.show()

sns.boxplot(data = RFM_score_table, x = 'Frequency', y = 'Segment', palette= "Set2")
plt.title("Frequency by Customer Segment")
plt.tight_layout()
plt.show()

"""#7. Suggest recommendation for marketing team to target customers in campaign


The potential customer segments for the company's marketing campaign are as follows:

**1. Potential Loyalist**: This customer segment represents the largest portion of customers (14.9%), consisting of 118 customers who made their most recent purchases within 45 days (ranked 5th). Although they contribute a relatively small revenue of $1,345.49, the marketing team should consider implementing cross-selling strategies for this customer segment.

**2. Champion**: The second-largest customer segment (13.1%) includes 104 customers who made their most recent purchases within 27 days (ranked 2nd). They contribute the highest average revenue of $4,435.91. This segment consists of customers who make frequent purchases, so there should be priority customer care programs for this segment, such as product discounts.

**3. Loyal**: This customer segment has a relatively low proportion (8.6%) with an average purchase frequency of 7.7 days, but they contribute the second-highest revenue of $3,948.21. To further assess the products for this segment, conducting product evaluation surveys is recommended in order to create suitable cross-selling and up-selling programs.

**4. Cannot Lose Them:** This customer segment has the lowest proportion (4.7%), but they have a higher purchase frequency than the "Loyal" segment (4.78 > 7.75). However, these customers made transactions 265 days ago. Therefore, new campaign strategies based on rewards, discounts, and special incentives for this customer group can be planned to attract and retain them. These strategies could be designed to make them feel special and appealing, ultimately encouraging their loyalty.


"""
